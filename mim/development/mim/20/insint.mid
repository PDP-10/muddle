;This code runs MIMI20 by interpretting TOPS20 instructions and building
;  a page trace

INTERP:	MOVEM	0,ACS0		; first save user ACS
	MOVE	0,[1,,ACS0+1]
	BLT	0,@[MIMSEC,,ACS0+17]
	XMOVEI	P,INTPDL	; get us a pdl
	SKIPE	PGJFN
	 JRST	INTER2		; already open
	SETZM	PAGNP
INTER1:	HRROI	A,[asciz /Output file for trace: /]
	PSOUT
	MOVE	A,[gj%sht+gj%fns]
	MOVE	B,[.priin,,.priout]
	GTJFN
	 JRST	INTER1
	MOVE	b,[440000,,300000]	;7-bit read/write
	OPENF
	 JRST	INTER1			;clever error handling
	MOVEM	A,PGJFN
INTER2:	HRROI	A,[ASCIZ /Place start PC in PCWD (global PC)
/]
	PSOUT
	HALTF

ILOOP:	MOVE	A,@PCWD			; get next instruction
	PUSHJ	P,INSINT
	JRST	ILOOP			; do it for a long time... 

;Instruction interpreter for producing page trace for multi-section
;analysis, ins is in A

INSINT:	PUSH	P,A
	MOVE	A,PCWD		; record pc page
	PUSHJ	P,PAGNOT	; note page
	POP	P,A
	AOS	PCWD		; bunp pc

INSIN1:	LDB	B,[331100,,A]	;OPCODE.
	LDB	C,[270400,,A]	;GET AC FIELD
	LDB	D,[220400,,A]	;INDX FIELD
	HRRZ	E,A		; EA FIELD
	MOVEI	F,0		; SEE IF IND
	TLNE	A,20		; SKIP IN NOT IND
	 MOVEI	F,1
	PUSHJ	P,EFFADR	; COMPUTE EFFECTIVE ADDRESS
	CAIN	B,<XCT_<-27.>>
	 JRST	DXCT
	CAIN	B,<PUSHJ_<-27.>>
	 JRST	DPUSHJ		;CALCULATE EA AND INTERPRET
	CAIN	B,<JSR_<-27.>>
	 JRST	DJSR
	CAIN	B,<JSA_<-27.>>
	 JRST	DJSA
;	CAIN	B,<JSYS_<-27.>>
;	 JRST	DJSYS
	CAIN	B,<JSP_<-27.>>
	 JRST	DJSP
	TRNN	B,700
	 JRST	DUUO
	CAIN	B,<POPJ_<-27.>>
	 JRST	DPOPJ
	CAIN	B,<JRA_<-27.>>
	 JRST	DJRA
	CAIN	B,<AOBJN_<-27.>>
	 JRST	DJMP
	CAIN	B,<AOBJP_<-27.>>
	 JRST	DJMP
	CAIN	B,<JFFO_<-27.>>
	 JRST	DJFFO
	CAIN	B,<JRST_<-27.>>
	 JRST	DJRST
	CAIN	B,<BLT_<-27.>>
	 JRST	DBLT
	CAIN	B,<123>
	 JRST	DXBLT
	CAIN	B,<PUSH_<-27.>>
	 JRST	DPUSH
	CAIN	B,<POP_<-27.>>
	 JRST	DPOP
	CAIN	B,<ILDB_<-27.>>
	 JRST	DILDB
	CAIN	B,<IDPB_<-27.>>
	 JRST	DILDB
	CAIN	B,<LDB_<-27.>>
	 JRST	DILDB
	MOVEI	0,(B)
	ANDI	0,770		; REMOVE LOW 3 BITS OF OPCODE
	CAIE	0,<AOJ_<-27.>>	; AOJ-SOMETHING
	CAIN	0,<SOJ_<-27.>>
	 JRST	DJMP
	CAIN	0,<JUMP_<-27.>>	; SOME FLAVOR JUMP
	 JRST	DJMP

; here for unexciting run of the mill instructions

DOINS:	PUSHJ	P,MEMTOU	; see if we touch memory
	 JRST	NOTOU		; no don't hack data structure

	EXCH	A,E
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT	; record page
	EXCH	A,E

NOTOU:	MOVEM	A,INSDO
	MOVEM	A,@[MIMSEC+1,,INSDO]
	HLLZ	A,PCWD
	HLLM	A,INSDIS
	HLLM	A,@[MIMSEC+1,,INSDIS]
	MOVEM	17,SAV17
	MOVSI	17,ACS0
	BLT	17,17
	JRST	@INSDIS
INSRET:	CAIA
	AOS	PCWD
	MOVEM	0,ACS0
	MOVE	0,[1,,ACS0+1]
	BLT	0,@[MIMSEC,,ACS0+17]
	MOVE	17,SAV17
	POPJ	P,

; interpret XCT instruction (E is effective address)

DXCT:	MOVE	A,E		;record page
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT
	PUSHJ	P,GETVAL	;get value
	PUSHJ	P,INSIN1	;do the instruction
	POPJ	P,

; here to inteprer PUSHJ

DPUSHJ: MOVE	B,PCWD		;get PC to push
	MOVE	A,ACS0(C)	;get stack pointer
	ADJSP	A,1		; bump stack pointer
	MOVEM	A,ACS0(C)
	SKIPGE	A		; skip if global
	 HLL	A,PCWD		; else use PC sect
	MOVEM	B,(A)		; store PC
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT	; and note page
	MOVEM	E,PCWD
	POPJ	P,

; do JSP interp

DJSP:	MOVE	B,PCWD		; set up PC to save
	MOVEM	B,ACS0(C)	; save it
	MOVEM	E,PCWD
	POPJ	P,

; here to do POPJ

DPOPJ:	MOVE	A,ACS0(C)	; get stack pointer
	SKIPGE	A
	 HLL	A,PCWD
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT	; note access
	MOVE	B,(A)
	MOVE	A,ACS0(C)
	ADJSP	A,-1
	MOVEM	A,ACS0(C)
	MOVEM	B,PCWD
	POPJ	P,

DUUO:
DJRA:
DJSA:
DJSR:
DJFFO:	HRROI	A,[ASCIZ /Not implemented...
/]
	PSOUT
	HALTF


; here to do BLT

DBLT:	MOVE	C,ACS0(C)	; get BLT register
	PUSH	P,A
	HLRZ	A,C
	HLL	A,E		; use eff addr of ins for sect
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT
	HRRZ	A,C
	HLL	A,E
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT
	POP	P,A
	JRST	DOINS

; here to do XBLT

DXBLT:	PUSH	P,A
      	MOVE	A,ACS0+1(C)
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT
	MOVE	A,ACS0+2(C)
	SKIPN	PCONLY
 	 PUSHJ	P,PAGNOT
	POP	P,A
	JRST	DOINS

; here to record PUSH

DPUSH:	PUSH	P,A
      	MOVE	A,ACS0(C)	;get stack pointer
	ADJSP	A,1		; bump stack pointer
	SKIPGE	A		; skip if global
	 HLL	A,PCWD		; else use PC sect
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT
	POP	P,A
	JRST	DOINS

; here to record POP

DPOP:	PUSH	P,A
     	SKIPG	A,ACS0(C)
	 HLL	A,PCWD
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT
	POP	P,A
	JRST	DOINS

; here for some byte pointe instructions

DILDB:	PUSH	P,A
	PUSHJ	P,GETVAL		; get the byte pointer
	LDB	0,[360600,,A]		; get shift
	CAILE	0,44			; skip if not single word global bp
	 JRST	DILDB1
	TLNE	A,40			; skip if not 2 word global bp
	 JRST	DILDB2
	LDB	D,[220400,,A]		; index field
	HRRZ	E,A
	MOVEI	F,0
	TLNE	A,20			; indirect?
	 MOVEI	F,1
DILDB3:	PUSHJ	P,EFFADR		; compute its effective address
	MOVE	A,E
	SKIPN	PCONLY
 	 PUSHJ	P,PAGNOT
	POP	P,A
	JRST	DOINS

DILDB1:	TLZ	A,770000
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT
	POP	P,A
	JRST	DOINS

DILDB2:	LDB	D,[360400,,A]
	MOVE	E,A
	TLZ	E,770000
	MOVEI	F,0
	TLNE	A,200000	
	 MOVEI	F,1
	JRST	DILDB3

; here to handle many of the possible jump instructions

DJMP:	LSH	B,27.		; start rebuilding jump instruction
	TLO	B,<<D>_5>	; will use D for test etc.
	HRRI	B,DJMP1		; where it will go
	MOVE	D,ACS0(C)	; get users register
	XCT	B
	CAIA

DJMP1:	MOVEM	E,PCWD		; store jumped PC
	MOVEM	D,ACS0(C)	; may have changed
	POPJ	P,

; here for jrst

DJRST:	CAIE	C,5		; only funny one is JRST 5, (XJRST)
	 JRST	DJRST1

	ADDI	E,1
	PUSHJ	P,GETVAL	; get PC word
	MOVEM	A,PCWD
	POPJ	P,

DJRST1:	MOVEM	E,PCWD
	POPJ	P,	

; Compute effective address 
;	E/	initial rh of instruction
;	F/	0 ==> no ind, 1 ==> ind
;	D/	indx field

EFFADR:	PUSH	P,A
	PUSH	P,0
       	MOVEI	0,100		; Maximum indirection count
	HRRES	E		; make negative offsets work

EFF1:	JUMPE	D,EFF2		; jump if no index field

	SKIPN	D,ACS0(D)	; get its contents
	 JRST	EFF2		; zero in index, ignore

	TLNE	D,-1		; skip if rh only (local index)
	 JUMPG	D,EFF3		; jump if global index

	ADD	E,D		; do local indexing
	ANDI	E,-1		; but prevent overflowing
	JRST	EFF2

EFF3:	ADD	E,D		; add global index

EFF2:	CAIGE	E,17		; AC?
	 JRST	EFF6
     	TLNN	E,400000	; negative addr also get current section
	 TLNN	E,-1		; skip if section already here
	  HLL	E,PCWD		; use PC section

EFF6:	JUMPE	F,EFF5		; no indirection, leave

	SOJGE	0,EFF4		; too much indirection
	HRROI	A,[ASCIZ /Too many levels of indirection
/]
	PSOUT
	HALTF

EFF4:	MOVE	A,E		; get page
	SKIPN	PCONLY
	 PUSHJ	P,PAGNOT

	PUSHJ	P,GETVAL	; get indirect word

	JUMPGE	A,EFF7		; jump if global ind

	LDB	D,[220400,,A]	; get index field
	TLNN	A,20		; skip if indirect
	 MOVEI	F,0		; turn it on
	HRRE	E,A		; keep original section with new address
	JRST	EFF1		; loop back

EFF7:	LDB	D,[360400,,A]
	TLNN	A,200000	; global indirect bit?
	 MOVEI	F,0
	TLZ	A,770000	; kill index and indirect
	MOVE	E,A
	JRST	EFF1

EFF5:	POP	P,0
     	POP	P,A
	POPJ	P,

; here to extract value

GETVAL:	CAILE	E,17		; skip if register
	 SKIPA	A,(E)		; get word
	  MOVE	A,ACS0(E)
	POPJ	P,

; here to take note of page being accessed (A is address)

PAGNOT:	CAIG	A,17		; not register
	 POPJ	P,

	AOS	PREFS
	SKIPE	CONFLI		; only recording conflicts?
	 JRST	PACON

	PUSH	P,B
	AOS	B,PAGNP
	MOVEM	A,PAGN-1(B)
	CAIL	B,512.
	 JRST	PAGNO1
	
	POP	P,B
	POPJ	P,

PAGNO1:	PUSH	P,A
	PUSH	P,C
       	MOVE	A,PGJFN
	MOVE	B,[444400,,PAGN]
	MOVNI	C,512.
	SOUT
	SETZM	PAGNP
	POP	P,C
	POP	P,A
	POP	P,B	
	POPJ	P,


PACON:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	LSH	A,-9.		; get to page group
	MOVE	B,A
	LSH	A,-2
	TRZ	A,777400	; kill sect # but not odd/even
	TRZE	A,200
	 TRC	A,20
	SKIPN	C,PTBL(A)
	 JRST	PACON1
	XOR	C,B
	TRZ	C,3		; kill low order bits
	JUMPE	C,PACON1
	MOVE	C,PTBL(A)
	MOVEM	B,PTBL(A)
	CAMG	B,C
	 EXCH	B,C
	HRL	B,C

	MOVSI	C,-CTBL		; see if this happened before
PALP:	CAMN	B,CTB(C)
	 JRST	PALP1
	SKIPN	CTB(C)
	 JRST	PALP2
	AOBJP	C,.+2
	AOBJN	C,PALP

	HRROI	A,[ASCIZ /Conflict table full? 
/]
	PSOUT
	HALTF

PALP2:	MOVEM	B,CTB(C)
PALP1:	AOSA	CTB+1(C)

PACON1:	MOVEM	B,PTBL(A)
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,

CONOUT:	MOVE	A,PGJFN
	MOVE	B,[444400,,CTB-1]
	MOVNI	C,CTBL
	SOUT
	MOVE	A,PGJFN
	CLOSF
	JFCL
	HALTF

IF1,[
DEFINE SDEF N
	OPS!N==0
	TERMIN

REPEAT <<512./36.>+1>,SDEF \.RPCNT

DEFINE OPTAB OP,IMM,\NIMM,LOP,N,FIRST,DONE
       DONE==0
       FIRST==1
       LOP==<<OP>_<-27.>>
       IFSE IMM,,[NIMM==0
		  IRPC X,XR,[OP]
		  IFSE [X]T,[IFN FIRST,[IRPC Y,,[XR]
					IFSE [Y]L,NIMM==1
					IFSE [Y]R,NIMM==1
					.ISTOP
					TERMIN
					DONE==1
]]
		  IFN DONE,.ISTOP
		  IFSE [X]I,NIMM==1
		  IFSN [X]I,NIMM==0
		  FIRST==0
		  TERMIN
]
       IFSN IMM,,NIMM==IMM
       N==<LOP/36.>
       SYMHACK \N,NIMM,LOP
       EXPUNGE N,NIMM,LOP
       TERMIN

DEFINE PRV A,B,C
	PRINTC /A B C
/
	TERMIN

DEFINE SYMHACK SNM,IMM,OP
	OPS!SNM==OPS!SNM\<IMM_<OP-<36.*<OP/36.>>>>
	TERMIN
        
OPTAB	JSYS,1		
OPTAB	ADJSP,1		
OPTAB	DFAD		
OPTAB	DFSB		
OPTAB	DFMP		
OPTAB	DFDV		
OPTAB	DADD		
OPTAB	DSUB		
OPTAB	DMUL		
OPTAB	DDIV		
OPTAB	DMOVE		
OPTAB	DMOVN		
OPTAB	FIX		
OPTAB	EXTEND	
OPTAB	DMOVEM	
OPTAB	DMOVNM	
OPTAB	FIXR		
OPTAB	FLTR		
OPTAB	UFA		
OPTAB	DFN		
OPTAB	FSC,1
OPTAB	IBP
OPTAB	ILDB
OPTAB	LDB
OPTAB	IDPB
OPTAB	DPB
OPTAB	FAD
OPTAB	FADL		
OPTAB	FADM
OPTAB	FADB
OPTAB	FADR
OPTAB	FADRI		
OPTAB	FADRM
OPTAB	FADRB
OPTAB	FSB
OPTAB	FSBL		
OPTAB	FSBM
OPTAB	FSBB
OPTAB	FSBR
OPTAB	FSBRI		
OPTAB	FSBRM
OPTAB	FSBRB
OPTAB	FMP
OPTAB	FMPL		
OPTAB	FMPM
OPTAB	FMPB
OPTAB	FMPR
OPTAB	FMPRI		
OPTAB	FMPRM
OPTAB	FMPRB
OPTAB	FDV
OPTAB	FDVL		
OPTAB	FDVM
OPTAB	FDVB
OPTAB	FDVR
OPTAB	FDVRI		
OPTAB	FDVRM
OPTAB	FDVRB
OPTAB	MOVE
OPTAB	MOVEI
OPTAB	MOVEM
OPTAB	MOVES
OPTAB	MOVS
OPTAB	MOVSI
OPTAB	MOVSM
OPTAB	MOVSS
OPTAB	MOVN
OPTAB	MOVNI
OPTAB	MOVNM
OPTAB	MOVNS
OPTAB	MOVM
OPTAB	MOVMI
OPTAB	MOVMM
OPTAB	MOVMS
OPTAB	IMUL
OPTAB	IMULI
OPTAB	IMULM
OPTAB	IMULB
OPTAB	MUL
OPTAB	MULI
OPTAB	MULM
OPTAB	MULB
OPTAB	IDIV
OPTAB	IDIVI
OPTAB	IDIVM
OPTAB	IDIVB
OPTAB	DIV
OPTAB	DIVI
OPTAB	DIVM
OPTAB	DIVB
OPTAB	ASH,1
OPTAB	ROT,1
OPTAB	LSH,1
OPTAB	JFFO	
OPTAB	ASHC,
OPTAB	ROTC,1
OPTAB	LSHC,1
OPTAB	CIRC	
OPTAB	EXCH
OPTAB	BLT
OPTAB	AOBJP
OPTAB	AOBJN
OPTAB	JRST
OPTAB	JFCL
OPTAB	XCT
OPTAB	MAP	
OPTAB	PUSHJ
OPTAB	PUSH
OPTAB	POP
OPTAB	POPJ
OPTAB	JSR
OPTAB	JSP
OPTAB	JSA
OPTAB	JRA
OPTAB	ADD
OPTAB	ADDI
OPTAB	ADDM
OPTAB	ADDB
OPTAB	SUB
OPTAB	SUBI
OPTAB	SUBM
OPTAB	SUBB
OPTAB	CAI
OPTAB	CAIL,1
OPTAB	CAIE,1
OPTAB	CAILE,1
OPTAB	CAIA,1
OPTAB	CAIGE,1
OPTAB	CAIN,1
OPTAB	CAIG,1
OPTAB	CAM
OPTAB	CAML
OPTAB	CAME
OPTAB	CAMLE
OPTAB	CAMA
OPTAB	CAMGE
OPTAB	CAMN
OPTAB	CAMG
OPTAB	JUMP
OPTAB	JUMPL
OPTAB	JUMPE
OPTAB	JUMPLE
OPTAB	JUMPA
OPTAB	JUMPGE
OPTAB	JUMPN
OPTAB	JUMPG
OPTAB	SKIP
OPTAB	SKIPL
OPTAB	SKIPE
OPTAB	SKIPLE
OPTAB	SKIPA
OPTAB	SKIPGE
OPTAB	SKIPN
OPTAB	SKIPG
OPTAB	AOJ
OPTAB	AOJL
OPTAB	AOJE
OPTAB	AOJLE
OPTAB	AOJA
OPTAB	AOJGE
OPTAB	AOJN
OPTAB	AOJG
OPTAB	AOS
OPTAB	AOSL
OPTAB	AOSE
OPTAB	AOSLE
OPTAB	AOSA
OPTAB	AOSGE
OPTAB	AOSN
OPTAB	AOSG
OPTAB	SOJ
OPTAB	SOJL
OPTAB	SOJE
OPTAB	SOJLE
OPTAB	SOJA
OPTAB	SOJGE
OPTAB	SOJN
OPTAB	SOJG
OPTAB	SOS
OPTAB	SOSL
OPTAB	SOSE
OPTAB	SOSLE
OPTAB	SOSA
OPTAB	SOSGE
OPTAB	SOSN
OPTAB	SOSG
OPTAB	SETZ,1
OPTAB	SETZI
OPTAB	SETZM
OPTAB	SETZB
OPTAB	AND
OPTAB	ANDI
OPTAB	ANDM
OPTAB	ANDB
OPTAB	ANDCA
OPTAB	ANDCAI
OPTAB	ANDCAM
OPTAB	ANDCAB
OPTAB	SETM
OPTAB	SETMI
OPTAB	SETMM
OPTAB	SETMB
OPTAB	ANDCM
OPTAB	ANDCMI
OPTAB	ANDCMM
OPTAB	ANDCMB
OPTAB	SETA,1
OPTAB	SETAI
OPTAB	SETAM
OPTAB	SETAB
OPTAB	XOR
OPTAB	XORI
OPTAB	XORM
OPTAB	XORB
OPTAB	IOR
OPTAB	IORI
OPTAB	IORM
OPTAB	IORB
OPTAB	ANDCB
OPTAB	ANDCBI
OPTAB	ANDCBM
OPTAB	ANDCBB
OPTAB	EQV
OPTAB	EQVI
OPTAB	EQVM
OPTAB	EQVB
OPTAB	SETCA,1
OPTAB	SETCAI
OPTAB	SETCAM
OPTAB	SETCAB
OPTAB	ORCA
OPTAB	ORCAI
OPTAB	ORCAM
OPTAB	ORCAB
OPTAB	SETCM
OPTAB	SETCMI
OPTAB	SETCMM
OPTAB	SETCMB
OPTAB	ORCM
OPTAB	ORCMI
OPTAB	ORCMM
OPTAB	ORCMB
OPTAB	ORCB
OPTAB	ORCBI
OPTAB	ORCBM
OPTAB	ORCBB
OPTAB	SETO,1
OPTAB	SETOI
OPTAB	SETOM
OPTAB	SETOB
OPTAB	HLL
OPTAB	HLLI
OPTAB	HLLM
OPTAB	HLLS
OPTAB	HRL
OPTAB	HRLI
OPTAB	HRLM
OPTAB	HRLS
OPTAB	HLLZ
OPTAB	HLLZI
OPTAB	HLLZM
OPTAB	HLLZS
OPTAB	HRLZ
OPTAB	HRLZI
OPTAB	HRLZM
OPTAB	HRLZS
OPTAB	HLLO
OPTAB	HLLOI
OPTAB	HLLOM
OPTAB	HLLOS
OPTAB	HRLO
OPTAB	HRLOI
OPTAB	HRLOM
OPTAB	HRLOS
OPTAB	HLLE
OPTAB	HLLEI
OPTAB	HLLEM
OPTAB	HLLES
OPTAB	HRLE
OPTAB	HRLEI
OPTAB	HRLEM
OPTAB	HRLES
OPTAB	HRR
OPTAB	HRRI
OPTAB	HRRM
OPTAB	HRRS
OPTAB	HLR
OPTAB	HLRI
OPTAB	HLRM
OPTAB	HLRS
OPTAB	HRRZ
OPTAB	HRRZI
OPTAB	HRRZM
OPTAB	HRRZS
OPTAB	HLRZ
OPTAB	HLRZI
OPTAB	HLRZM
OPTAB	HLRZS
OPTAB	HRRO
OPTAB	HRROI
OPTAB	HRROM
OPTAB	HRROS
OPTAB	HLRO
OPTAB	HLROI
OPTAB	HLROM
OPTAB	HLROS
OPTAB	HRRE
OPTAB	HRREI
OPTAB	HRREM
OPTAB	HRRES
OPTAB	HLRE
OPTAB	HLREI
OPTAB	HLREM
OPTAB	HLRES
OPTAB	TRN
OPTAB	TLN
OPTAB	TRNE
OPTAB	TLNE
OPTAB	TRNA
OPTAB	TLNA
OPTAB	TRNN
OPTAB	TLNN
OPTAB	TDN
OPTAB	TSN
OPTAB	TDNE
OPTAB	TSNE
OPTAB	TDNA
OPTAB	TSNA
OPTAB	TDNN
OPTAB	TSNN
OPTAB	TRZ
OPTAB	TLZ
OPTAB	TRZE
OPTAB	TLZE
OPTAB	TRZA
OPTAB	TLZA
OPTAB	TRZN
OPTAB	TLZN
OPTAB	TDZ
OPTAB	TSZ
OPTAB	TDZE
OPTAB	TSZE
OPTAB	TDZA
OPTAB	TSZA
OPTAB	TDZN
OPTAB	TSZN
OPTAB	TRC
OPTAB	TLC
OPTAB	TRCE
OPTAB	TLCE
OPTAB	TRCA
OPTAB	TLCA
OPTAB	TRCN
OPTAB	TLCN
OPTAB	TDC
OPTAB	TSC
OPTAB	TDCE
OPTAB	TSCE
OPTAB	TDCA
OPTAB	TSCA
OPTAB	TDCN
OPTAB	TSCN
OPTAB	TRO
OPTAB	TLO
OPTAB	TROE
OPTAB	TLOE
OPTAB	TROA
OPTAB	TLOA
OPTAB	TRON
OPTAB	TLON
OPTAB	TDO
OPTAB	TSO
OPTAB	TDOE
OPTAB	TSOE
OPTAB	TDOA
OPTAB	TSOA
OPTAB	TDON
OPTAB	TSON

DEFINE SYMDEP N
	OPS!N
	TERMIN
]

OPTB:

REPEAT <<512./36.>+1>,SYMDEP \.RPCNT

;Determine if opcode touches memory, get opcode in B skips if touches mem

MEMTOU:	PUSH	P,B
	PUSH	P,C
	IDIVI	B,36.
	MOVE	B,OPTB(B)
	MOVNS	C
	ROT	B,-1(C)
	POP	P,C
	SKIPL	B
	 AOS	-1(P)
	POP	P,B
	POPJ	P,		


CONSTANTS


PAGNP:	0
PAGN:	BLOCK	512.
PAGNEN:

PGJFN:	0
ACS0:	BLOCK	20
PCWD:	0
INTPDL:	BLOCK	100
SAV17:	0
PREFS:	0
PTBL:	BLOCK	200
CTBL==10000
CTB:	BLOCK	CTBL
CONFLI:	0
PCONLY:	-1
MUMBLE:	-1